<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fond animé — Cyberpunk Neon</title>
<style>
  :root{
    /* Palette néon (clair mais punchy) */
    --bg: #0a0b10;
    --neon-pink: #ff3cac;
    --neon-cyan: #2bd9ff;
    --neon-violet: #8f00ff;
    --neon-yellow: #f6ff6b;
    --grid: #161a25;
    --scanline: rgba(255,255,255,.06);
  }
  @media (prefers-color-scheme: light){
    :root{ --bg:#0a0b10 } /* on garde un “night mode” pour le cyberpunk */
  }

  html,body{height:100%;margin:0;background:var(--bg);color:#e8ecff;font:16px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;overflow:hidden}
  .stage{position:fixed; inset:0; isolation:isolate}

  /* 0) Vignette douce pour cadrer l'œil */
  .vignette{position:absolute; inset:-10%; pointer-events:none;
    background: radial-gradient(120vmax 70vmax at 50% 50%, transparent 60%, rgba(0,0,0,.35) 100%);
    z-index:10;
  }

  /* 1) Halo “néon aurora” */
  .aurora{
    position:absolute; inset:-20% -20% -20% -20%; filter: blur(42px) saturate(130%);
    background:
      radial-gradient(40vmax 28vmax at 20% 20%, color-mix(in oklab, var(--neon-pink) 55%, transparent), transparent 60%),
      radial-gradient(45vmax 30vmax at 80% 25%, color-mix(in oklab, var(--neon-cyan) 55%, transparent), transparent 62%),
      radial-gradient(36vmax 24vmax at 70% 78%, color-mix(in oklab, var(--neon-violet) 45%, transparent), transparent 65%);
    mix-blend-mode: screen;
    animation: auroraFloat 28s ease-in-out infinite alternate;
    will-change: transform;
  }
  @keyframes auroraFloat{
    0%{ transform: translate3d(0,0,0) scale(1)}
    100%{ transform: translate3d(0,-1.5%,0) scale(1.02)}
  }

  /* 2) Soleil holographique (scan radial) */
  .sun{
    position:absolute; left:50%; top:32%;
    width:min(52vmin, 56vw); aspect-ratio:1/1;
    transform: translate(-50%,-50%);
    border-radius:50%;
    background:
      radial-gradient(circle at 50% 60%, color-mix(in oklab, var(--neon-pink) 25%, transparent) 0 30%, transparent 60%),
      conic-gradient(from 0deg, color-mix(in oklab, var(--neon-cyan) 35%, transparent), transparent 40%, color-mix(in oklab, var(--neon-violet) 35%, transparent), transparent 80%, color-mix(in oklab, var(--neon-pink) 35%, transparent));
    box-shadow: 0 0 80px color-mix(in oklab, var(--neon-pink) 40%, transparent),
                0 0 120px color-mix(in oklab, var(--neon-cyan) 30%, transparent);
    opacity:.9;
    overflow:hidden;
  }
  .sun::after{
    content:""; position:absolute; inset:0;
    background: repeating-linear-gradient( to bottom,
      rgba(255,255,255,.12) 0 3px, transparent 3px 8px );
    mix-blend-mode: overlay; opacity:.35;
    animation: sunScan 6s linear infinite;
  }
  @keyframes sunScan{
    from{ transform: translateY(-8%) }
    to  { transform: translateY(8%) }
  }

  /* 3) Grille en perspective (au sol) */
  .grid{
    position:absolute; inset:0; pointer-events:none; transform-origin:50% 100%;
    transform: perspective(800px) rotateX(68deg) translateY(20%);
    background:
      linear-gradient(var(--grid), var(--grid)) 0 0/100% 1px,
      linear-gradient(90deg, var(--grid), var(--grid)) 0 0/1px 100%;
    mask-image: linear-gradient(to top, rgba(0,0,0,.8), rgba(0,0,0,.3), transparent 70%);
  }
  .grid::before{
    content:""; position:absolute; inset:-200% -200% 0 -200%;
    background:
      repeating-linear-gradient(0deg, transparent 0 56px, var(--grid) 56px 57px),
      repeating-linear-gradient(90deg, transparent 0 56px, var(--grid) 56px 57px);
    animation: gridDrift 16s linear infinite;
    opacity:.9;
  }
  @keyframes gridDrift{
    from{ transform: translate3d(0,0,0) }
    to  { transform: translate3d(-56px,-56px,0) }
  }

  /* 4) Scanlines globales (CRT subtil) */
  .scanlines{
    position:absolute; inset:0; pointer-events:none; opacity:.28; mix-blend-mode:soft-light;
    background: repeating-linear-gradient( to bottom, var(--scanline) 0 1px, transparent 1px 3px );
    animation: scanPulse 3.2s ease-in-out infinite alternate;
  }
  @keyframes scanPulse{
    0%{ opacity:.18}
    100%{ opacity:.30}
  }

  /* 5) Particules canvas (lumière néon) */
  canvas#fx{ position:absolute; inset:0; width:100%; height:100%;
    filter: drop-shadow(0 0 6px #00ffff) drop-shadow(0 0 10px #ff33cc);
    opacity:.85;
  }

  /* 6) Glitch noise très léger (texture) */
  .noise{
    position:absolute; inset:-1% -1% -1% -1%; pointer-events:none; opacity:.12; mix-blend-mode:overlay;
    background-image: url('data:image/svg+xml;utf8,\
      <svg xmlns="http://www.w3.org/2000/svg" width=\"160\" height=\"160\" viewBox=\"0 0 160 160\">\
      <filter id=\"n\"><feTurbulence type=\"fractalNoise\" baseFrequency=\"0.95\" numOctaves=\"2\"/></filter>\
      <rect width=\"100%\" height=\"100%\" filter=\"url(%23n)\" opacity=\"0.4\"/>\
      </svg>');
    animation: jitter 5s steps(2,end) infinite;
  }
  @keyframes jitter{
    0%{ transform:translate3d(0,0,0) }
    100%{ transform:translate3d(-1%,1%,0) }
  }

  /* Slot (facultatif) pour logo/texte; masqué par défaut */
  .slot{position:absolute; inset:0; display:grid; place-items:center; z-index:6; opacity:0}
  .slot h1{font-size:clamp(28px,6vw,56px); letter-spacing:.06em; text-transform:uppercase}

  /* Accessibilité */
  @media (prefers-reduced-motion: reduce){
    .aurora, .sun::after, .grid::before, .scanlines, .noise{ animation:none !important }
    canvas#fx{ display:none }
  }
</style>
</head>
<body>
<div class="stage" aria-hidden="true">
  <div class="aurora"></div>
  <div class="sun"></div>
  <div class="grid"></div>
  <canvas id="fx"></canvas>
  <div class="scanlines"></div>
  <div class="noise"></div>
  <div class="vignette"></div>

  <!-- Optionnel : retire ce bloc pour n’afficher QUE le fond -->
  <div class="slot"><h1>NEON CITY</h1></div>
</div>

<script>
/* Particules néon (légères, mobile-friendly) */
(function(){
  const cnv = document.getElementById('fx');
  const ctx = cnv.getContext('2d', { alpha: true });
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let W=0, H=0, pts=[];

  const CFG = {
    COUNT_BASE: 90,        // densité base (auto-scalée)
    SIZE_MIN: 0.9,
    SIZE_MAX: 2.4,
    SPEED_MIN: 0.05,
    SPEED_MAX: 0.22,
    LINK_DIST: 120,
    LINK_ALPHA: 0.13
  };
  function rnd(a,b){ return a + Math.random()*(b-a) }

  function resize(){
    const rect = cnv.getBoundingClientRect();
    W = Math.floor(rect.width * dpr);
    H = Math.floor(rect.height * dpr);
    cnv.width = W; cnv.height = H;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    const area = rect.width*rect.height;
    const n = Math.round(CFG.COUNT_BASE * (area / (1280*720)));
    spawn(n);
  }

  function spawn(n){
    pts.length = 0;
    for(let i=0;i<n;i++){
      const hue = Math.random() < 0.5 ? 305 : 190; // magenta ou cyan
      pts.push({
        x: Math.random()*W/dpr,
        y: Math.random()*H/dpr,
        vx: rnd(-CFG.SPEED_MAX, CFG.SPEED_MAX),
        vy: rnd(-CFG.SPEED_MAX, CFG.SPEED_MAX),
        r: rnd(CFG.SIZE_MIN, CFG.SIZE_MAX),
        hue,
      });
    }
  }

  function step(){
    ctx.clearRect(0,0,cnv.width/dpr,cnv.height/dpr);

    // update/draw points
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.998; p.vy *= 0.998; // léger freinage
      // rebond
      if(p.x<0||p.x>cnv.width/dpr){ p.vx*=-1; p.x = Math.max(0, Math.min(cnv.width/dpr, p.x)) }
      if(p.y<0||p.y>cnv.height/dpr){ p.vy*=-1; p.y = Math.max(0, Math.min(cnv.height/dpr, p.y)) }

      // point
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, .9)`;
      ctx.fill();

      // halo
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*2.1, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, .10)`;
      ctx.fill();
    }

    // liaisons
    for(let i=0;i<pts.length;i++){
      for(let j=i+1;j<pts.length;j++){
        const a=pts[i], b=pts[j];
        const dx=a.x-b.x, dy=a.y-b.y;
        const dist = Math.hypot(dx,dy);
        if(dist < CFG.LINK_DIST){
          const alpha = (1 - dist/CFG.LINK_DIST) * CFG.LINK_ALPHA;
          // dégradé vers le centre de l’écran
          ctx.strokeStyle = `rgba(43,217,255,${alpha})`;
          if(a.hue===305 || b.hue===305) ctx.strokeStyle = `rgba(255,60,172,${alpha})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    requestAnimationFrame(step);
  }

  // Petit “kick” au scroll (donne vie au décor)
  let drift = 0;
  window.addEventListener('wheel', (e)=>{
    const s = Math.sign(e.deltaY);
    drift += s*0.02;
    for(const p of pts){ p.vy += drift*0.002 }
    drift *= 0.95;
  }, {passive:true});

  window.addEventListener('resize', resize);
  resize(); requestAnimationFrame(step);
})();
</script>
</body>
</html>
