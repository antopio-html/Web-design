<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fond animé futuriste</title>
<style>
  :root{
    /* Palette claire et douce */
    --bg: #f6faf9;
    --glow-a: #bff6ef; /* vert-eau */
    --glow-b: #e6f0ff; /* bleu très pâle */
    --glow-c: #f9f1ff; /* lavande pâle */
    --grid: #e8eef2;
    --grain: rgba(0,0,0,.04);
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0b1013; --glow-a:#073b3b; --glow-b:#101b38; --glow-c:#1c1235; --grid:#15202a;
      --grain: rgba(255,255,255,.04);
    }
  }

  html,body{height:100%; margin:0; background:var(--bg)}
  body{overflow:hidden; font:16px/1 system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif}

  /* Conteneur plein écran — le fond OCCUPE TOUT */
  .stage{position:fixed; inset:0; isolation:isolate}

  /* 1) Aurora (dégradés fluides) — ultra doux, GPU friendly */
  .aurora{
    position:absolute; inset:-20% -20% -20% -20%; filter: blur(40px) saturate(120%);
    background:
      radial-gradient(40vmax 28vmax at 12% 18%, color-mix(in oklab, var(--glow-a) 75%, transparent), transparent 60%),
      radial-gradient(44vmax 30vmax at 80% 18%, color-mix(in oklab, var(--glow-b) 70%, transparent), transparent 62%),
      radial-gradient(38vmax 26vmax at 70% 80%, color-mix(in oklab, var(--glow-c) 70%, transparent), transparent 65%),
      radial-gradient(28vmax 22vmax at 16% 74%, color-mix(in oklab, var(--glow-b) 40%, transparent), transparent 70%),
      var(--bg);
    mix-blend-mode: screen;
    animation: floatA 28s ease-in-out infinite alternate;
    will-change: transform;
  }
  @keyframes floatA{
    0%   { transform: translate3d(0,0,0) scale(1) }
    100% { transform: translate3d(0,-2%,0) scale(1.02) }
  }

  /* 2) Grille dynamique très subtile (lignes claires) */
  .grid{
    position:absolute; inset:0; pointer-events:none; opacity:.6; mask-image: radial-gradient(60vmax 40vmax at 50% 45%, #000 60%, transparent 100%);
  }
  .grid::before,
  .grid::after{
    content:""; position:absolute; inset:-2px; background:
      repeating-linear-gradient(0deg,   transparent 0 46px, var(--grid) 46px 47px, transparent 47px 93px),
      repeating-linear-gradient(90deg,  transparent 0 46px, var(--grid) 46px 47px, transparent 47px 93px);
    transform: translateZ(0);
  }
  .grid::before{ animation: gridPanX 26s cubic-bezier(.2,.8,.2,1) infinite }
  .grid::after { animation: gridPanY 32s cubic-bezier(.2,.8,.2,1) infinite reverse }
  @keyframes gridPanX{
    0% { transform: translate3d(0,0,0) }
    100%{ transform: translate3d(-46px,0,0) }
  }
  @keyframes gridPanY{
    0% { transform: translate3d(0,0,0) }
    100%{ transform: translate3d(0,-46px,0) }
  }

  /* 3) Particules (canvas) — rendu faible densité */
  canvas#fx{
    position:absolute; inset:0; width:100%; height:100%;
    filter: drop-shadow(0 0 6px color-mix(in oklab, var(--glow-a) 30%, transparent));
    opacity:.75;
  }

  /* Grain très délicat (texture, évite l’effet plastifié) */
  .grain{
    position:absolute; inset:-2% -2% -2% -2%; pointer-events:none; opacity:.35;
    background-image: url('data:image/svg+xml;utf8,\
      <svg xmlns="http://www.w3.org/2000/svg" width=\"140\" height=\"140\" viewBox=\"0 0 140 140\">\
      <filter id=\"n\"><feTurbulence type=\"fractalNoise\" baseFrequency=\"0.9\" numOctaves=\"2\" stitchTiles=\"stitch\"/></filter>\
      <rect width=\"100%\" height=\"100%\" filter=\"url(%23n)\" opacity=\"0.06\"/>\
      </svg>');
    mix-blend-mode: overlay;
    animation: grainShift 6s steps(2,end) infinite;
  }
  @keyframes grainShift{
    0%{ transform:translate3d(0,0,0) }
    100%{ transform:translate3d(-2%,1%,0) }
  }

  /* Slot de contenu optionnel (si jamais tu veux mettre un logo plus tard) */
  .slot{
    position:absolute; inset:0; display:grid; place-items:center; z-index:1;
    color:#0f1115; mix-blend-mode:multiply; opacity:.0; /* masqué (fond uniquement) */
  }

  /* Accessibilité : réduit fortement les animations si demandé */
  @media (prefers-reduced-motion: reduce){
    .aurora, .grid::before, .grid::after, .grain{ animation: none !important }
    canvas#fx{ display:none }
  }
</style>
</head>
<body>
<div class="stage" aria-hidden="true">
  <div class="aurora"></div>
  <div class="grid"></div>
  <canvas id="fx"></canvas>
  <div class="grain"></div>

  <!-- Optionnel : enlève complètement ce bloc pour n’avoir que le fond -->
  <div class="slot">
    <!-- <h1>Ton logo ici</h1> -->
  </div>
</div>

<script>
/* Particules légères & douces — optimisées mobile */
(function(){
  const cnv = document.getElementById('fx');
  const ctx = cnv.getContext('2d', { alpha: true });
  let dpr = Math.min(window.devicePixelRatio || 1, 2); // limite DPR pour perf
  let W=0, H=0;

  const CFG = {
    COUNT_BASE: 80,          // densité de base (sera ajustée selon taille)
    SIZE_MIN: 0.8,
    SIZE_MAX: 2.2,
    SPEED_MIN: 0.04,
    SPEED_MAX: 0.18,
    LINK_DIST: 110,          // distance de liaison
    LINK_ALPHA: 0.12
  };

  let pts = [];

  function rnd(a,b){ return a + Math.random()*(b-a) }
  function resize(){
    const rect = cnv.getBoundingClientRect();
    W = Math.floor(rect.width  * dpr);
    H = Math.floor(rect.height * dpr);
    cnv.width = W; cnv.height = H;
    ctx.setTransform(dpr,0,0,dpr,0,0); // normalise coords
    // recalculer la densité selon surface
    const area = rect.width*rect.height;
    const count = Math.round(CFG.COUNT_BASE * (area / (1200*700)));
    spawn(count);
  }

  function spawn(n){
    pts = [];
    for(let i=0;i<n;i++){
      pts.push({
        x: Math.random()*W/dpr,
        y: Math.random()*H/dpr,
        vx: rnd(-CFG.SPEED_MAX, CFG.SPEED_MAX),
        vy: rnd(-CFG.SPEED_MAX, CFG.SPEED_MAX),
        r: rnd(CFG.SIZE_MIN, CFG.SIZE_MAX),
        hue: rnd(168, 210) // entre vert-eau et bleu doux
      });
    }
  }

  function step(t){
    ctx.clearRect(0,0,cnv.width/dpr,cnv.height/dpr);

    // update & draw points
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      p.x += p.vx; p.y += p.vy;

      // friction légère = "douceur" (freinage)
      p.vx *= 0.998; p.vy *= 0.998;

      // rebond souple
      if(p.x < 0 || p.x > cnv.width/dpr){ p.vx *= -1; p.x = Math.max(0, Math.min(cnv.width/dpr, p.x)); }
      if(p.y < 0 || p.y > cnv.height/dpr){ p.vy *= -1; p.y = Math.max(0, Math.min(cnv.height/dpr, p.y)); }

      // halo point
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${p.hue}, 70%, 60%, 0.8)`;
      ctx.fill();

      // léger glow
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*2.2, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${p.hue}, 70%, 60%, 0.06)`;
      ctx.fill();
    }

    // liaisons
    for(let i=0;i<pts.length;i++){
      for(let j=i+1;j<pts.length;j++){
        const a = pts[i], b = pts[j];
        const dx = a.x-b.x, dy = a.y-b.y;
        const d2 = dx*dx + dy*dy;
        const dist = Math.sqrt(d2);
        if(dist < CFG.LINK_DIST){
          const alpha = (1 - dist/CFG.LINK_DIST) * CFG.LINK_ALPHA;
          ctx.strokeStyle = `rgba(16,179,179,${alpha})`; // proche de --acc
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    requestAnimationFrame(step);
  }

  // wheel vertical = léger drift sur la vitesse (option sympa)
  let drift = 0;
  window.addEventListener('wheel', (e)=>{
    const s = Math.sign(e.deltaY);
    drift += s * 0.02;
    // applique un petit offset sur les vitesses
    for(const p of pts){ p.vy += drift * 0.002 }
    drift *= 0.95;
  }, {passive:true});

  // resize & start
  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
