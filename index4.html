<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fond animé — Cyberpunk Stable & Hyper-animé</title>
<style>
  :root{
    --bg:#0a0b10;
    --neon-pink:#ff3cac;
    --neon-cyan:#2bd9ff;
    --neon-violet:#8f00ff;
    --grid:#161a25;
    --ink:#e8ecff;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);overflow:hidden;
    font:16px/1 Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}

  .stage{position:fixed; inset:0; isolation:isolate}

  /* 1) AURORA — blobs néon (sans radar) */
  .aurora{
    position:absolute; inset:-20% -20% -20% -20%; filter: blur(44px) saturate(130%);
    background:
      radial-gradient(42vmax 30vmax at 18% 22%, color-mix(in oklab, var(--neon-pink) 55%, transparent), transparent 60%),
      radial-gradient(46vmax 30vmax at 78% 28%, color-mix(in oklab, var(--neon-cyan) 55%, transparent), transparent 62%),
      radial-gradient(36vmax 26vmax at 72% 78%, color-mix(in oklab, var(--neon-violet) 45%, transparent), transparent 65%);
    mix-blend-mode: screen;
    animation: auroraFloat 26s ease-in-out infinite alternate;
  }
  @keyframes auroraFloat{
    0%{ transform: translate3d(0,0,0) scale(1)}
    100%{ transform: translate3d(0,-1.6%,0) scale(1.02)}
  }

  /* 2) BEAMS — faisceaux néon obliques qui balayent l’écran */
  .beams{
    position:absolute; inset:-10% -20% -10% -20%; pointer-events:none; mix-blend-mode:screen; opacity:.75;
  }
  .beams::before,
  .beams::after{
    content:""; position:absolute; inset:-20%;
    background:
      linear-gradient( 60deg, transparent 0 40%, color-mix(in oklab, var(--neon-cyan) 55%, transparent) 48%, transparent 58%),
      linear-gradient(120deg, transparent 0 42%, color-mix(in oklab, var(--neon-pink) 55%, transparent) 50%, transparent 60%),
      linear-gradient( 75deg, transparent 0 55%, color-mix(in oklab, var(--neon-violet) 45%, transparent) 60%, transparent 70%);
    filter: blur(10px);
  }
  .beams::before{ animation: sweepA 12s cubic-bezier(.2,.8,.2,1) infinite }
  .beams::after { animation: sweepB 18s cubic-bezier(.2,.8,.2,1) infinite reverse }
  @keyframes sweepA{ from{transform:translateX(-8%) rotate(-2deg)} to{transform:translateX(8%) rotate(2deg)} }
  @keyframes sweepB{ from{transform:translateX(6%) rotate(3deg)} to{transform:translateX(-6%) rotate(-3deg)} }

  /* 3) GRID — sol en perspective discret (lent) */
  .grid{
    position:absolute; inset:0; pointer-events:none; transform-origin:50% 100%;
    transform: perspective(900px) rotateX(69deg) translateY(28%);
    background:
      linear-gradient(var(--grid), var(--grid)) 0 0/100% 1px,
      linear-gradient(90deg, var(--grid), var(--grid)) 0 0/1px 100%;
    mask-image: linear-gradient(to top, rgba(0,0,0,.85), rgba(0,0,0,.4), transparent 70%);
  }
  .grid::before{
    content:""; position:absolute; inset:-200% -200% 0 -200%;
    background:
      repeating-linear-gradient(0deg, transparent 0 56px, var(--grid) 56px 57px),
      repeating-linear-gradient(90deg, transparent 0 56px, var(--grid) 56px 57px);
    animation: gridDrift 22s linear infinite;
  }
  @keyframes gridDrift{ from{transform:translate3d(0,0,0)} to{transform:translate3d(-56px,-56px,0)} }

  /* 4) SCANLINES + GLITCH BARS */
  .scanlines{
    position:absolute; inset:0; pointer-events:none; opacity:.22; mix-blend-mode:soft-light;
    background: repeating-linear-gradient(to bottom, rgba(255,255,255,.06) 0 1px, transparent 1px 3px);
    animation: scanPulse 3s ease-in-out infinite alternate;
  }
  @keyframes scanPulse{0%{opacity:.16}100%{opacity:.28}}

  .glitch{
    position:absolute; inset:0; pointer-events:none; mix-blend-mode:screen; opacity:.65;
    background:
      linear-gradient( to right, transparent, color-mix(in oklab, var(--neon-cyan) 22%, transparent), transparent ) 0 10%/100% 2px no-repeat,
      linear-gradient( to right, transparent, color-mix(in oklab, var(--neon-pink) 22%, transparent), transparent ) 0 60%/100% 2px no-repeat;
    animation: glitchBars 4s steps(2,end) infinite;
  }
  @keyframes glitchBars{
    0%,100%{ transform:translateY(0) }
    20%{ transform:translateY(-2px) }
    40%{ transform:translateY(1px) }
    60%{ transform:translateY(-1px) }
    80%{ transform:translateY(2px) }
  }

  /* 5) CANVAS particules & étincelles (streaks) */
  canvas#fx{ position:absolute; inset:0; width:100%; height:100%; opacity:.9;
    filter: drop-shadow(0 0 6px #00ffff) drop-shadow(0 0 10px #ff33cc);
  }

  /* 6) Vignette douce */
  .vignette{position:absolute; inset:-10%; pointer-events:none;
    background: radial-gradient(120vmax 70vmax at 50% 50%, transparent 60%, rgba(0,0,0,.35) 100%); z-index:10;}

  /* Slot optionnel (masqué) */
  .slot{position:absolute; inset:0; display:grid; place-items:center; opacity:0}

  /* Réduction d’animations */
  @media (prefers-reduced-motion: reduce){
    .aurora, .beams::before, .beams::after, .grid::before, .scanlines, .glitch{ animation:none !important }
    canvas#fx{ display:none }
  }
</style>
</head>
<body>
<div class="stage" aria-hidden="true">
  <div class="aurora"></div>
  <div class="beams"></div>
  <div class="grid"></div>
  <canvas id="fx"></canvas>
  <div class="scanlines"></div>
  <div class="glitch"></div>
  <div class="vignette"></div>
  <div class="slot"><!-- logo/texte si besoin --></div>
</div>

<script>
/* ===========================
   Canvas Néon — STABLE & RICHE
   - Sans O(n²) lourd par défaut
   - Traînées (streaks) via fade
   - Étincelles aléatoires
   - DPR limité, pause tab caché
=========================== */
(function(){
  const cnv = document.getElementById('fx');
  const ctx = cnv.getContext('2d', { alpha:true });
  let dpr = Math.min(window.devicePixelRatio || 1, 1.75); // cap DPR pour stabilité
  let W=0, H=0, running=true;

  // Pool d’objets pour éviter allocations
  const MAX_PART = 140;   // densité maîtrisée
  const MAX_SPARK= 22;    // étincelles temporaires
  const parts = new Array(MAX_PART);
  const sparks= new Array(MAX_SPARK);

  function rand(a,b){ return a + Math.random()*(b-a) }
  function resize(){
    const r = cnv.getBoundingClientRect();
    W = (r.width|0) * dpr;
    H = (r.height|0) * dpr;
    cnv.width = W; cnv.height = H;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function init(){
    for(let i=0;i<MAX_PART;i++){
      parts[i] = {
        x: Math.random()*W/dpr, y: Math.random()*H/dpr,
        vx: rand(-0.35,0.35), vy: rand(-0.22,0.22),
        r: rand(0.8, 2.1),
        hue: Math.random()<0.5 ? 305 : 190, // magenta / cyan
      };
    }
    for(let i=0;i<MAX_SPARK;i++){
      sparks[i] = { x:0,y:0,vx:0,vy:0,r:0,life:0,hue:305 };
    }
  }

  // Étincelle (réutilise objets)
  function spawnSpark(x,y){
    for(let i=0;i<MAX_SPARK;i++){
      const s = sparks[i];
      if(s.life<=0){
        s.x=x; s.y=y; s.vx=rand(-1.5,1.5); s.vy=rand(-1.5,1.5);
        s.r=rand(0.8,1.8); s.life=rand(18,34); s.hue=Math.random()<.5?305:190;
        break;
      }
    }
  }

  // Animation
  let last=0;
  function frame(ts){
    if(!running){ last=ts; requestAnimationFrame(frame); return; }
    const dt = Math.min(32, ts-last || 16); last=ts;

    // Fade douce pour conserver des traînées
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle='rgba(10,11,16,0.12)'; // petit voile au lieu d'un clear total
    ctx.fillRect(0,0,cnv.width/dpr,cnv.height/dpr);

    // Particules
    ctx.globalCompositeOperation='lighter';
    for(let i=0;i<MAX_PART;i++){
      const p=parts[i];
      p.x+=p.vx; p.y+=p.vy;
      // friction
      p.vx*=0.998; p.vy*=0.998;
      // wrap plutôt que rebond (plus soft, moins collisions)
      if(p.x< -10) p.x=cnv.width/dpr+10; else if(p.x>cnv.width/dpr+10) p.x=-10;
      if(p.y< -10) p.y=cnv.height/dpr+10; else if(p.y>cnv.height/dpr+10) p.y=-10;

      // point
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fillStyle=`hsla(${p.hue}, 100%, 60%, .9)`; ctx.fill();

      // halo
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r*2.2,0,Math.PI*2);
      ctx.fillStyle=`hsla(${p.hue}, 100%, 60%, .06)`; ctx.fill();

      // chance de spawn étincelle
      if(Math.random()<0.003) spawnSpark(p.x,p.y);
    }

    // Étincelles (brèves, sans liens)
    for(let i=0;i<MAX_SPARK;i++){
      const s=sparks[i]; if(s.life<=0) continue;
      s.life-=1;
      s.x+=s.vx; s.y+=s.vy;
      s.vx*=0.99; s.vy*=0.99;
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fillStyle=`hsla(${s.hue},100%,70%,${Math.max(0,s.life/34)})`;
      ctx.fill();
    }

    requestAnimationFrame(frame);
  }

  // Interactions légères : drift molette + étincelles clic/touch
  let drift=0;
  window.addEventListener('wheel', e=>{
    const s=Math.sign(e.deltaY);
    drift += s*0.02;
    for(const p of parts){ p.vy += drift*0.004 }
    drift*=0.92;
  }, {passive:true});

  function spawnBurst(x,y){
    const rect=cnv.getBoundingClientRect();
    const rx = x - rect.left, ry = y - rect.top;
    spawnSpark(rx,ry);
    // petit kick radial
    for(let k=0;k<8;k++) spawnSpark(rx+rand(-6,6), ry+rand(-6,6));
  }
  window.addEventListener('pointerdown', e=> spawnBurst(e.clientX, e.clientY), {passive:true});

  // Pause si onglet caché → stabilité et batterie
  document.addEventListener('visibilitychange', ()=>{
    running = !document.hidden;
  });

  // Resize (debounce léger)
  let rAF=null;
  window.addEventListener('resize', ()=>{
    if(rAF) cancelAnimationFrame(rAF);
    rAF = requestAnimationFrame(()=>{
      dpr = Math.min(window.devicePixelRatio || 1, 1.75);
      resize();
    });
  });

  resize(); init(); requestAnimationFrame(frame);
})();
</script>
</body>
</html>
