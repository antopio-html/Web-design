<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Vitrine Web • Chat 3D qui danse</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: radial-gradient(1200px 800px at 50% 20%, #f7fbff 0%, #eef7f5 40%, #e9f3f1 60%, #e6f0ee 100%); overflow: hidden; }
    #app { position: fixed; inset: 0; }
    /* Mini watermark discret (facultatif) — supprime-le si tu veux vraiment "uniquement" le chat */
    .mark { position: fixed; left: 12px; bottom: 10px; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#6b7; opacity:.55; user-select:none }
  </style>
</head>
<body>
  <canvas id="app"></canvas>
  <div class="mark">Chat 3D qui danse • WebGL (Three.js)</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ------ Base ------
    const canvas = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xeaf2ef, 18, 42);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(6, 4.2, 9);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 6;
    controls.maxDistance = 14;
    controls.minPolarAngle = Math.PI * 0.2;
    controls.maxPolarAngle = Math.PI * 0.49;

    // ------ Lumières ------
    const hemi = new THREE.HemisphereLight(0xffffff, 0xbfd6cf, 0.7);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(6, 10, 6);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.near = 1;
    key.shadow.camera.far = 40;
    scene.add(key);

    // Un petit "disco" dynamique très léger
    const disco = new THREE.PointLight(0xffffff, 0.35, 0, 2.0);
    disco.castShadow = false;
    scene.add(disco);

    // ------ Sol ------
    const groundGeo = new THREE.CircleGeometry(10, 64);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xeaf5f0, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.receiveShadow = true;
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // ------ Chat (voxel/chibi) ------
    const cat = new THREE.Group();
    scene.add(cat);

    const pastelBody = new THREE.MeshStandardMaterial({ color: 0xf3c6a6, roughness: 0.85, metalness: 0.05 });
    const pastelHead = new THREE.MeshStandardMaterial({ color: 0xf8d7bf, roughness: 0.8, metalness: 0.05 });
    const pastelEar  = new THREE.MeshStandardMaterial({ color: 0xf6b9ab, roughness: 0.8, metalness: 0.05 });
    const pastelDark = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.6, metalness: 0.2 });
    const pastelTail = new THREE.MeshStandardMaterial({ color: 0xf1cdb3, roughness: 0.85, metalness: 0.05 });
    const eyeMat     = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x111111, roughness: 0.5, metalness: 0.2 });
    const noseMat    = new THREE.MeshStandardMaterial({ color: 0xe48e8e, roughness: 0.6, metalness: 0.1 });

    // Corps
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.4, 1.2, 1.4), pastelBody);
    body.castShadow = true; body.receiveShadow = true;
    body.position.set(0, 1, 0);
    cat.add(body);

    // Ventre (tache)
    const belly = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.9, 1.2), new THREE.MeshStandardMaterial({ color: 0xf9e7da, roughness: 0.9 }));
    belly.position.set(0, 1, 0.01);
    belly.castShadow = false; belly.receiveShadow = false;
    cat.add(belly);

    // Tête
    const head = new THREE.Group(); head.position.set(1.2, 2.0, 0);
    const headBox = new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.3, 1.3), pastelHead);
    headBox.castShadow = true; headBox.receiveShadow = true;
    head.add(headBox);

    // Oreilles
    const earGeo = new THREE.ConeGeometry(0.28, 0.45, 4);
    const earL = new THREE.Mesh(earGeo, pastelEar);
    const earR = new THREE.Mesh(earGeo, pastelEar);
    earL.rotation.z = Math.PI; earR.rotation.z = Math.PI;
    earL.position.set(-0.35, 0.75, -0.2);
    earR.position.set( 0.35, 0.75, -0.2);
    earL.castShadow = earR.castShadow = true;
    head.add(earL, earR);

    // Yeux
    const eyeGeo = new THREE.SphereGeometry(0.09, 16, 16);
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
    const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
    eyeL.position.set(-0.3, 0.12, 0.61);
    eyeR.position.set( 0.3, 0.12, 0.61);
    head.add(eyeL, eyeR);

    // Nez
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.18, 8), noseMat);
    nose.rotation.x = Math.PI / 2;
    nose.position.set(0, -0.15, 0.66);
    head.add(nose);

    // Moustaches (deux petites barres)
    const whiskerGeo = new THREE.BoxGeometry(0.5, 0.02, 0.02);
    const wL1 = new THREE.Mesh(whiskerGeo, pastelDark);
    const wL2 = new THREE.Mesh(whiskerGeo, pastelDark);
    const wR1 = new THREE.Mesh(whiskerGeo, pastelDark);
    const wR2 = new THREE.Mesh(whiskerGeo, pastelDark);
    wL1.position.set(-0.35, -0.18, 0.64); wL1.rotation.z = 0.05;
    wL2.position.set(-0.35, -0.12, 0.64); wL2.rotation.z = -0.05;
    wR1.position.set( 0.35, -0.18, 0.64); wR1.rotation.z = -0.05;
    wR2.position.set( 0.35, -0.12, 0.64); wR2.rotation.z = 0.05;
    head.add(wL1, wL2, wR1, wR2);

    cat.add(head);

    // Pattes
    function leg() {
      const g = new THREE.Group();
      const upper = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.4), pastelBody);
      const lower = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.5, 0.35), pastelBody);
      const paw   = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.18, 0.45), new THREE.MeshStandardMaterial({ color: 0xf9e7da, roughness: 0.9 }));
      upper.castShadow = lower.castShadow = paw.castShadow = true;
      upper.position.y = 0.25;
      lower.position.y = -0.2;
      paw.position.y   = -0.55;
      g.add(upper, lower, paw);
      g.castShadow = true;
      return g;
    }

    const legFL = leg(); legFL.position.set( 0.8, 0.8,  0.45); // avant gauche
    const legFR = leg(); legFR.position.set( 0.8, 0.8, -0.45); // avant droite
    const legBL = leg(); legBL.position.set(-0.8, 0.8,  0.45); // arrière gauche
    const legBR = leg(); legBR.position.set(-0.8, 0.8, -0.45); // arrière droite
    cat.add(legFL, legFR, legBL, legBR);

    // Queue
    const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.16, 2.2, 12), pastelTail);
    tail.castShadow = true;
    tail.position.set(-1.2, 1.6, 0);
    tail.rotation.z = Math.PI / 2.3;
    cat.add(tail);

    // Léger dégradé de "pelage" (bande sombre)
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.12, 1.4), pastelDark);
    stripe.position.set(0, 1.35, 0);
    stripe.castShadow = false; stripe.receiveShadow = false;
    stripe.material.opacity = 0.08; stripe.material.transparent = true;
    cat.add(stripe);

    // Position initiale
    cat.position.y = 0;
    cat.rotation.y = Math.PI * 0.15;

    // ------ Animation "danse" ------
    let t0 = performance.now();
    function animate(now) {
      const t = (now - t0) / 1000;

      // Rythmes
      const beat  = Math.sin(t * 2.1);        // tempo principal
      const beat2 = Math.sin(t * 3.2);        // contretemps
      const sway  = Math.sin(t * 1.2);        // balancement latéral
      const hop   = Math.max(0, Math.sin(t * 2.1)); // petits sauts (0..1)

      // Corps : rebond + sway
      body.position.y = 1 + hop * 0.08;
      cat.position.y  = hop * 0.06;
      cat.rotation.y  = Math.sin(t * 0.6) * 0.25;

      // Tête : tilt + nod
      head.rotation.z = sway * 0.12;
      head.rotation.x = Math.sin(t * 2.1 + Math.PI/6) * 0.08;
      head.position.y = 2.0 + hop * 0.05;

      // Pattes en "pas chassés" / alternance
      const a = 0.55, b = 0.45;
      legFL.rotation.x =  a * Math.sin(t * 2.1) + 0.1;
      legFR.rotation.x = -a * Math.sin(t * 2.1) + 0.1;
      legBL.rotation.x = -b * Math.sin(t * 2.1) - 0.05;
      legBR.rotation.x =  b * Math.sin(t * 2.1) - 0.05;

      // Queue : wag + petit cercle
      tail.rotation.y = Math.sin(t * 3.0) * 0.5;
      tail.rotation.x = Math.cos(t * 1.5) * 0.2;

      // Disco light en orbite
      disco.position.set(Math.cos(t*1.2)*4, 3 + Math.sin(t*2.0)*0.7, Math.sin(t*1.2)*4);
      disco.color.setHSL((t*0.08)%1, 0.6, 0.55);

      controls.update();
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);

    // ------ Réglages responsive ------
    function onResize() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // Petite intro douce
    scene.position.y = 0.2;
    let intro = 0;
    (function introTick(){
      intro += 0.02;
      scene.position.y = THREE.MathUtils.damp(scene.position.y, 0, 0.08, 1/60);
      requestAnimationFrame(introTick);
    })();
  </script>
</body>
</html>
