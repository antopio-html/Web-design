<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tunnel 3D Scroll ‚Äî Zoom In/Out</title>
<meta name="description" content="Scroll = avance cam√©ra : √©l√©ments arrivent du fond vers le premier plan puis sortent du cadre.">
<style>
  :root{
    --bg:#0a0b0f;
    --ink:#ececf1;
    --muted:#a7a7b5;
    --primary:#ff1f43;
    --panel:#111219;
    --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0}
  body{
    background:
      radial-gradient(900px 400px at 80% -10%, rgba(255,31,67,.12), transparent),
      radial-gradient(800px 400px at 10% 30%, rgba(255,31,67,.08), transparent),
      var(--bg);
    color:var(--ink); font:15px/1.6 Inter, system-ui, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
    overflow-x:hidden;
  }
  a{color:inherit; text-decoration:none}

  /* Viewport fix√© : on ‚Äú√©pingle‚Äù l‚Äôaffichage */
  .viewport{
    position:fixed; inset:0; overflow:hidden;
    perspective: 1200px; perspective-origin: 50% 50%;
    /* pour un effet plus "zoom", baisse la perspective (900px, 700px‚Ä¶) */
  }

  /* Sc√®ne 3D : on d√©place la cam√©ra le long de Z (en fait on translate la sc√®ne) */
  .scene{
    position:absolute; inset:0;
    transform-style:preserve-3d;
    will-change: transform;
  }

  /* HUD / overlay fixe */
  header{
    position:fixed; top:0; left:0; right:0; z-index:10;
    display:flex; align-items:center; justify-content:space-between;
    padding:12px 16px;
    background:linear-gradient(to bottom, rgba(10,11,15,.6), rgba(10,11,15,0));
    border-bottom:1px solid rgba(255,255,255,.05);
    backdrop-filter: blur(8px) saturate(1.1);
  }
  .brand{display:flex; gap:10px; align-items:center; font-weight:800; letter-spacing:.5px}
  .dot{width:12px; height:12px; border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #fff, #fff0 30%),
               linear-gradient(180deg, var(--primary), #b3122b);
    box-shadow:0 0 18px rgba(255,31,67,.55);
  }
  .hud{
    display:flex; align-items:center; gap:10px; color:#d4d4de; font-size:13px;
  }
  .bar{
    width:160px; height:6px; border-radius:999px; background:#1a1b24; overflow:hidden; border:1px solid #23232f;
  }
  .bar>i{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--primary),#ff94a7)}

  /* Cartes/√©l√©ments 3D */
  .layer{
    position:absolute; top:50%; left:50%;
    transform-style:preserve-3d;
    transform: translate(-50%,-50%) translateZ(var(--z, 0px)) scale(var(--s,1)) rotateX(var(--rx,0deg)) rotateY(var(--ry,0deg));
    opacity:var(--o,1);
    filter: blur(var(--blur, 0px)) saturate(1.05);
    transition: filter .1s linear;
    will-change: transform, opacity, filter;
  }

  .card{
    min-width: min(520px, 86vw);
    padding:18px;
    border-radius:var(--radius);
    background:linear-gradient(180deg, #161823, #0f1118);
    border:1px solid #222436;
    box-shadow:
      0 24px 60px rgba(0,0,0,.5),
      inset 0 0 40px rgba(255,255,255,.04);
  }
  .card h2{margin:.2rem 0 .4rem; font-size:22px}
  .card p{color:var(--muted); margin:.2rem 0}

  /* Vignettes / puces */
  .chip{display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px;
        background:#1a0d11; color:#ffb2bf; border:1px solid #2a1419; margin-right:6px}

  /* Astuces UI */
  .hint{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%); z-index:10;
    color:#c8c8d5; font-size:13px; opacity:.85; user-select:none;
    backdrop-filter: blur(6px); background:rgba(10,11,15,.35); border:1px solid rgba(255,255,255,.06);
    padding:8px 10px; border-radius:999px;
  }

  /* Grand espace de scroll ‚Äúvirtuel‚Äù pour piloter la cam√©ra */
  .scrollspace{ height: 8000px } /* ajuste la longueur du voyage */

  /* Discret grain + halo pour futurisme */
  .grain{
    position:fixed; inset:-40px; z-index:0; opacity:.06; pointer-events:none; mix-blend-mode:soft-light;
    background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency=".9" numOctaves="2"/></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');
    animation:grain 6s steps(2) infinite;
  }
  @keyframes grain{to{transform:translate(50px,0)}}

  /* Responsive tweaks */
  @media (max-width:560px){
    .card{min-width: 92vw}
  }
</style>
</head>
<body>
<header>
  <div class="brand"><span class="dot" aria-hidden="true"></span> Tunnel 3D ‚Äî D√©mo</div>
  <div class="hud">
    <span>Profondeur</span>
    <div class="bar" aria-label="Progression de profondeur"><i id="prog"></i></div>
    <span id="depthVal">Z: 0m</span>
  </div>
</header>

<!-- Viewport fixe et sc√®ne 3D -->
<div class="viewport" aria-hidden="false" aria-label="Sc√®ne 3D">
  <div class="scene" id="scene">
    <!-- LAYERS ‚Äî data-z = position initiale le long de Z (n√©gative = loin, positive = vers l'avant) -->
    <!-- On r√©partit les couches tous les ~800px en Z -->
    <div class="layer" data-z="-4000">
      <div class="card">
        <span class="chip">Intro</span>
        <h2>Bienvenue dans le tunnel 3D</h2>
        <p>Scrollez pour ‚Äúavancer‚Äù : les cartes viennent du fond vers vous, deviennent nettes et repartent.</p>
      </div>
    </div>

    <div class="layer" data-z="-3200">
      <div class="card">
        <span class="chip">Concept</span>
        <h2>Cam√©ra ‚Üí Z</h2>
        <p>La cam√©ra progresse en profondeur. Perspective CSS, <code>translateZ</code>, et √©chelle ‚âà distance.</p>
      </div>
    </div>

    <div class="layer" data-z="-2400">
      <div class="card">
        <span class="chip">FX</span>
        <h2>Nettet√© & Opacit√©</h2>
        <p>Plus un √©l√©ment est loin, plus il est petit, flou et transparent. Quand il passe au plan 0, il est net.</p>
      </div>
    </div>

    <div class="layer" data-z="-1600">
      <div class="card">
        <span class="chip">Timing</span>
        <h2>Fen√™tre unique, sc√®nes qui ‚Äúentrent‚Äù</h2>
        <p>Le viewport est fix√©. Les anciens √©l√©ments sortent du cadre en arri√®re-plan.</p>
      </div>
    </div>

    <div class="layer" data-z="-800">
      <div class="card">
        <span class="chip">Motion</span>
        <h2>L√©ger Tilt Parallaxe</h2>
        <p>Inclinaison subtile au pointeur pour apporter du relief, sans g√™ner la lisibilit√©.</p>
      </div>
    </div>

    <div class="layer" data-z="0">
      <div class="card">
        <span class="chip">Focus</span>
        <h2>Plan Z = 0</h2>
        <p>Ici, l‚Äô√©l√©ment est ‚Äúau premier plan‚Äù : taille 1, nettet√© max, opacit√© 1.</p>
      </div>
    </div>

    <div class="layer" data-z="800">
      <div class="card">
        <span class="chip">Suite</span>
        <h2>Sortie progressive</h2>
        <p>En poursuivant, la carte passe devant vous et s‚Äô√©loigne (r√©tr√©cit, redevient floue).</p>
      </div>
    </div>

    <div class="layer" data-z="1600">
      <div class="card">
        <span class="chip">Custom</span>
        <h2>Ajoutez vos sc√®nes</h2>
        <p>Dupliquez une <code>.layer</code> et r√©glez <code>data-z</code> par pas de 700~900 pour rythmer le voyage.</p>
      </div>
    </div>

    <div class="layer" data-z="2400">
      <div class="card">
        <span class="chip">Fin</span>
        <h2>Atterrissage</h2>
        <p>On arrive au bout. Haut/Bas = +/- profondeur. PgUp/PgDn sautent d‚Äôune sc√®ne.</p>
      </div>
    </div>
  </div>
</div>

<!-- Espace de scroll virtuel pour piloter la profondeur -->
<div class="scrollspace" aria-hidden="true"></div>
<div class="grain" aria-hidden="true"></div>

<div class="hint">üñ±Ô∏è Scrollez ‚Ä¢ ‚å®Ô∏è ‚Üë/‚Üì ‚Ä¢ PgUp/PgDn ‚Ä¢ (mobile : glissez)</div>

<script>
/*
  Principe :
  - Le viewport est FIXE (position:fixed).
  - On mappe le scroll (page ‚Äúfant√¥me‚Äù) √† une profondeur cam√©ra (cameraZ).
  - Chaque .layer a un data-z (sa position ‚Äúmonde‚Äù).
  - On calcule depth = layerZ - cameraZ, puis :
      scale ‚âà clamp( 1 / (1 + depth/1000) , 0.25..2 )
      opacity, blur en fonction de |depth|
      translateZ = depth (pour la perspective)
*/
(function(){
  const scene = document.getElementById('scene');
  const layers = Array.from(document.querySelectorAll('.layer'));
  const prog = document.getElementById('prog');
  const depthText = document.getElementById('depthVal');

  // R√©glages ‚Äúphysiques‚Äù
  const config = {
    // Profondeur totale pilot√©e par la hauteur de scrollspace (voir CSS)
    // On mappe 0..scrollMax -> cameraZ range.
    zMin: -4500,     // d√©part loin
    zMax:  3000,     // arriv√©e devant
    blurMax: 12,     // px
    visibilityZ: 2600, // au-del√† de cette distance, fade out
    tiltMax: 6,      // deg (tilt pointeur)
    scaleClampMin: .28,
    scaleClampMax: 2.4
  };

  let targetCamZ = config.zMin;
  let camZ = targetCamZ;

  function scrollToZ(){
    const h = document.documentElement;
    const p = (h.scrollTop) / ((h.scrollHeight - h.clientHeight) || 1);
    // Lissage ‚Äúsmooth‚Äù : easeInOut
    targetCamZ = config.zMin + (config.zMax - config.zMin)*p;
  }

  function updateHUD(){
    const h = document.documentElement;
    const p = (h.scrollTop) / ((h.scrollHeight - h.clientHeight) || 1);
    prog.style.width = (p*100).toFixed(2)+'%';
    depthText.textContent = `Z: ${Math.round(camZ)}m`;
  }

  addEventListener('scroll', scrollToZ, {passive:true});
  scrollToZ();

  // Tilt parallax au pointeur
  let tiltX=0, tiltY=0, ttx=0, tty=0;
  addEventListener('pointermove', (e)=>{
    const cx = innerWidth/2, cy = innerHeight/2;
    const nx = (e.clientX - cx)/cx; // -1..1
    const ny = (e.clientY - cy)/cy;
    tiltY = nx * config.tiltMax;
    tiltX = -ny * config.tiltMax;
  }, {passive:true});

  // Touch scrolling inertiel (mobile)
  let touching=false, lastY=0, vY=0;
  addEventListener('touchstart', e=>{ touching=true; lastY=e.touches[0].clientY; vY=0 }, {passive:true});
  addEventListener('touchmove', e=>{
    if(!touching) return;
    const y = e.touches[0].clientY;
    const dy = lastY - y;
    lastY = y;
    window.scrollBy(0, dy);
    vY = dy;
  }, {passive:false});
  addEventListener('touchend', ()=>{ touching=false; });

  // Contr√¥les clavier
  addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(k==='arrowdown') window.scrollBy({top: 200, behavior:'smooth'});
    if(k==='arrowup') window.scrollBy({top: -200, behavior:'smooth'});
    if(k==='pageDown'.toLowerCase()) window.scrollBy({top: innerHeight*.8, behavior:'smooth'});
    if(k==='pageUp'.toLowerCase()) window.scrollBy({top: -innerHeight*.8, behavior:'smooth'});
  });

  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

  function render(){
    // Easing cam√©ra
    camZ += (targetCamZ - camZ)*0.08;

    // Easing tilt
    ttx += (tiltX - ttx)*0.12;
    tty += (tiltY - tty)*0.12;

    // Applique tilt √† la sc√®ne enti√®re (l√©ger)
    scene.style.transform = `rotateX(${ttx}deg) rotateY(${tty}deg)`;

    // Met √† jour chaque couche
    for(const L of layers){
      const z0 = parseFloat(L.dataset.z)||0;
      const depth = z0 - camZ; // distance relative √† la cam√©ra (0 = plan focal)
      // √âchelle bas√©e sur la profondeur (plus proche => plus grand)
      const scale = clamp( 1 / (1 + (depth/1200)), config.scaleClampMin, config.scaleClampMax );
      // Opacit√© et flou : fade quand trop loin
      const ad = Math.abs(depth);
      const o = clamp(1 - (ad/config.visibilityZ), 0, 1);
      const blur = (1 - Math.max(0, 1 - ad/900)) * config.blurMax; // 0 pr√®s, max loin

      // D√©calage vertical subtil quand on ‚Äúpasse‚Äù le plan
      const yOffset = (depth/40); // donne une sensation de passage

      L.style.setProperty('--z', `${depth.toFixed(2)}px`);
      L.style.setProperty('--s', scale.toFixed(3));
      L.style.setProperty('--o', o.toFixed(3));
      L.style.setProperty('--blur', blur.toFixed(2)+'px');
      L.style.setProperty('--rx', (ttx*0.35).toFixed(2)+'deg');
      L.style.setProperty('--ry', (tty*0.35).toFixed(2)+'deg');

      L.style.transform =
        `translate(-50%,-50%) translateZ(${depth}px) translateY(${yOffset}px) `+
        `scale(${scale}) rotateX(${ttx*0.35}deg) rotateY(${tty*0.35}deg)`;

      // Accessibilit√©: aria-hidden si trop loin
      if(o < 0.05) {
        L.setAttribute('aria-hidden','true');
      } else {
        L.removeAttribute('aria-hidden');
      }
    }

    updateHUD();
    requestAnimationFrame(render);
  }
  render();
})();
</script>
</body>
</html>
