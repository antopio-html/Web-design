<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tunnel 3D — Pause + Stick (soft)</title>
<meta name="description" content="Viewport fixe, scroll/Swipe = avance caméra. Pause lisible au focus, puis carte qui suit légèrement avant de disparaître.">
<style>
  :root{
    --bg:#080a0f; --ink:#ececf1; --muted:#a7a7b5; --primary:#ff1f43; --panel:#0f1118; --radius:14px; --focus:#ff7185;
  }
  *{box-sizing:border-box} html,body{height:100%; margin:0}
  body{
    background:
      radial-gradient(900px 400px at 80% -10%, rgba(255,31,67,.12), transparent),
      radial-gradient(800px 400px at 10% 30%, rgba(255,31,67,.08), transparent),
      var(--bg);
    color:var(--ink);
    font: clamp(14px, 1.3vw, 16px)/1.6 Inter, system-ui, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
    overflow-x:hidden; -webkit-tap-highlight-color: transparent;
  }
  a{color:inherit; text-decoration:none}

  /* Viewport fixe */
  .viewport{
    position:fixed; inset:0; overflow:hidden;
    perspective: clamp(760px, 85vw, 1100px); /* moins “zoomé” pour du confort */
    perspective-origin: 50% 50%;
    touch-action:none;
  }
  .scene{ position:absolute; inset:0; transform-style:preserve-3d; will-change: transform }

  header{
    position:fixed; inset:0 0 auto 0; z-index:10; display:flex; align-items:center; justify-content:space-between;
    padding: clamp(8px, 2.5vw, 14px) clamp(10px, 3vw, 18px);
    background:linear-gradient(to bottom, rgba(8,10,15,.6), rgba(8,10,15,0));
    border-bottom:1px solid rgba(255,255,255,.06); backdrop-filter: blur(10px) saturate(1.1);
  }
  .brand{display:flex; gap:10px; align-items:center; font-weight:800; letter-spacing:.5px; font-size: clamp(14px, 2.8vw, 16px)}
  .dot{width:12px; height:12px; border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #fff, #fff0 30%), linear-gradient(180deg, var(--primary), #b3122b);
    box-shadow:0 0 14px rgba(255,31,67,.5);
  }
  .hud{display:flex; align-items:center; gap:10px; color:#d4d4de; font-size:12px}
  .bar{width: clamp(120px, 30vw, 200px); height:6px; border-radius:999px; background:#1a1b24; overflow:hidden; border:1px solid #23232f}
  .bar>i{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--primary),#ff94a7)}
  .state{padding:4px 8px; border-radius:999px; border:1px solid #2b2d3d; background:#131520; color:#dcdce6}

  /* Couches */
  .layer{
    position:absolute; top:50%; left:50%;
    transform-style:preserve-3d; will-change: transform, opacity, filter;
    opacity:var(--o,1); filter: blur(var(--blur, 0px)) saturate(1.05);
  }
  .card{
    min-width: min(560px, 92vw);
    padding: clamp(14px, 3.2vw, 20px);
    border-radius: clamp(12px, 2.8vw, 16px);
    background:linear-gradient(180deg, #161823, var(--panel));
    border:1px solid #222436;
    box-shadow: 0 22px 56px rgba(0,0,0,.5), inset 0 0 36px rgba(255,255,255,.04);
    transition: box-shadow .25s, border-color .25s, transform .25s;
  }
  .card h2{margin:.2rem 0 .45rem; font-size: clamp(18px, 4.5vw, 24px)}
  .card p{color:var(--muted); margin:.2rem 0; font-size: clamp(13px, 3.7vw, 15px)}
  .chip{display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px;
        background:#1a0d11; color:#ffb2bf; border:1px solid #2a1419; margin-right:6px}

  /* Focus visuel */
  .focused .card{
    border-color: var(--focus);
    box-shadow:
      0 26px 64px rgba(255,31,67,.42),
      0 0 0 1px rgba(255,255,255,.06) inset,
      0 0 0 2px rgba(255,113,133,.16);
  }

  .hint{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%); z-index:10;
    color:#c8c8d5; font-size:12px; opacity:.9; user-select:none;
    backdrop-filter: blur(6px); background:rgba(10,11,15,.35); border:1px solid rgba(255,255,255,.06);
    padding:8px 10px; border-radius:999px;
  }

  /* Contrôles */
  .ctrls{
    position:fixed; right:12px; bottom:72px; z-index:12; display:flex; flex-direction:column; gap:10px;
  }
  .ctrls button{
    width:48px; height:48px; border-radius:12px; border:1px solid #26293a; background:#13151f; color:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.4); font-size:18px; touch-action:none;
  }
  .ctrls button:active{transform:scale(.98)}

  .scrollspace{ height: 1600px } /* compat desktop */
</style>
</head>
<body>
<header>
  <div class="brand"><span class="dot" aria-hidden="true"></span> Tunnel 3D — Démo</div>
  <div class="hud" aria-label="Profondeur">
    <div class="bar" title="Progression"><i id="prog"></i></div>
    <span id="depthVal">Z: 0</span>
    <span class="state" id="state">Mode: libre</span>
  </div>
</header>

<div class="viewport" id="viewport" aria-label="Scène 3D">
  <div class="scene" id="scene">
    <!-- Répartis par ~800 en Z -->
    <div class="layer" data-z="-3600"><div class="card"><span class="chip">Intro</span><h2>Bienvenue</h2><p>Swipe / Scroll = avance douce dans le tunnel 3D.</p></div></div>
    <div class="layer" data-z="-2800"><div class="card"><span class="chip">Concept</span><h2>Caméra en Z</h2><p>Perspective CSS + translateZ. Les objets viennent du fond, deviennent nets, repartent.</p></div></div>
    <div class="layer" data-z="-2000"><div class="card"><span class="chip">FX</span><h2>Netteté & Opacité</h2><p>Distance → taille, blur, opacity. Focus au plan Z=0.</p></div></div>
    <div class="layer" data-z="-1200"><div class="card"><span class="chip">Rythme</span><h2>Pause lisible</h2><p>Petite pause au focus, puis la carte suit un peu le mouvement.</p></div></div>
    <div class="layer" data-z="-400"><div class="card"><span class="chip">Focus</span><h2>Plan 0</h2><p>Lisibilité maximale avant la sortie du cadre.</p></div></div>
    <div class="layer" data-z="400"><div class="card"><span class="chip">Suite</span><h2>Suivi fluide</h2><p>Elle s’accroche légèrement à la caméra puis s’éloigne.</p></div></div>
    <div class="layer" data-z="1200"><div class="card"><span class="chip">Custom</span><h2>Vos contenus</h2><p>Dupliquez une <code>.layer</code> et réglez <code>data-z</code>.</p></div></div>
    <div class="layer" data-z="2000"><div class="card"><span class="chip">Fin</span><h2>Atterrissage</h2><p>► / ◄ ou ↑/↓ pour piloter tranquillement.</p></div></div>
  </div>
</div>

<div class="ctrls" aria-label="Contrôles">
  <button id="back" aria-label="Reculer">◄</button>
  <button id="fw" aria-label="Avancer">►</button>
</div>

<div class="scrollspace" aria-hidden="true"></div>
<div class="hint">Swipe / Scroll doux • Pause au focus • La carte “colle” un peu avant de partir</div>

<script>
/*
  Mode “soft” :
  - Moins dynamique (sensibilité réduite + damping).
  - Pause (DWELL_MS) quand proche du plan 0.
  - “Stick” : après la pause, la carte suit partiellement le mouvement pendant STICK_MS,
    via un offset de profondeur proportionnel au déplacement caméra, qui décroît progressivement.
*/
(function(){
  const scene = document.getElementById('scene');
  const viewport = document.getElementById('viewport');
  const layers = Array.from(document.querySelectorAll('.layer'));
  const prog = document.getElementById('prog');
  const depthText = document.getElementById('depthVal');
  const stateText = document.getElementById('state');
  const btnFw = document.getElementById('fw');
  const btnBk = document.getElementById('back');

  const cfg = {
    zMin: -3800,
    zMax:  2300,
    blurMax: 12,
    visibilityZ: 2400,
    tiltMax: 4,
    scaleClampMin: .30,
    scaleClampMax: 2.2,

    /* >>> moins dynamique */
    SPEED: 0.9,          // wheel réactivité (↓)
    TOUCH_SENS: 1.4,     // swipe réactivité (↓)
    KEY_STEP: 160,       // pas clavier (↓)
    BTN_STEP: 220,       // pas boutons (↓)

    /* pause & snap */
    SNAP_WIN: 170,       // fenêtre de lock autour du plan
    DWELL_MS: 1500,      // durée de pause lisible (ms)
    BREAK_FORCE: 520,    // geste minimal pour casser la pause (↑ = plus dur à casser)

    /* stick (suivi après la pause) */
    STICK_MS: 900,       // durée du suivi
    STICK_FACTOR: 0.5,   // proportion de déplacement caméra suivie par la carte (0..1)
    FADE_STICK_PX: 380   // “crédit” de distance retiré du calcul d’opacité au début du stick
  };

  /* état */
  let targetZ = cfg.zMin;
  let camZ = cfg.zMin;
  let vZ = 0;

  let tiltX=0, tiltY=0, ttx=0, tty=0;

  let mode = 'free';          // 'free' | 'dwell'
  let dwellTimer = 0;
  let focusedIndex = -1;

  // état stick
  let stick = { active:false, index:-1, startCamZ:0, startTime:0 };

  function setMode(m){
    mode = m;
    stateText.textContent = 'Mode: ' + (m==='dwell' ? 'pause' : 'libre');
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
  function updateHUD(){
    const p = (camZ - cfg.zMin) / (cfg.zMax - cfg.zMin);
    prog.style.width = (Math.max(0,Math.min(1,p))*100).toFixed(1)+'%';
    depthText.textContent = `Z: ${Math.round(camZ)}`;
  }
  function nearestLayerIndex(z){
    let best=-1, dmin=1e9;
    for(let i=0;i<layers.length;i++){
      const z0 = +layers[i].dataset.z || 0;
      const d = Math.abs(z0 - z);
      if(d<dmin){ dmin=d; best=i; }
    }
    return best;
  }

  function enterDwell(i){
    focusedIndex = i;
    const z0 = +layers[i].dataset.z || 0;
    targetZ = z0; vZ = 0; dwellTimer = performance.now() + cfg.DWELL_MS;
    setMode('dwell');
    layers.forEach(L=>L.classList.remove('focused'));
    layers[i].classList.add('focused');
    // fin du stick précédent si existant
    stick.active = false;
  }
  function beginStick(i){
    stick.active = true;
    stick.index = i;
    stick.startCamZ = camZ;
    stick.startTime = performance.now();
  }
  function exitDwell(startStick=true){
    const i = focusedIndex;
    setMode('free');
    layers.forEach(L=>L.classList.remove('focused'));
    dwellTimer = 0; focusedIndex = -1;
    if(startStick && i>=0) beginStick(i);
  }

  /* tilt pointeur */
  addEventListener('pointermove', e=>{
    const cx = innerWidth/2, cy = innerHeight/2;
    const nx = (e.clientX - cx)/cx;
    const ny = (e.clientY - cy)/cy;
    tty = nx * cfg.tiltMax;
    ttx = -ny * cfg.tiltMax;
  }, {passive:true});

  /* wheel (moins sensible) */
  addEventListener('wheel', e=>{
    const dy = e.deltaY;
    const impulse = dy * cfg.SPEED;
    if(mode==='dwell'){
      if(Math.abs(impulse) >= cfg.BREAK_FORCE){ exitDwell(true); vZ += impulse; }
    } else {
      vZ += impulse;
    }
    e.preventDefault();
  }, {passive:false});

  /* touch (moins réactif) */
  let touching=false, lastY=0, lastT=0;
  viewport.addEventListener('touchstart', e=>{
    touching=true; vZ*=0.3;
    lastY = e.touches[0].clientY; lastT = performance.now();
  }, {passive:true});
  viewport.addEventListener('touchmove', e=>{
    if(!touching) return;
    const y = e.touches[0].clientY;
    const dy = (lastY - y) * cfg.TOUCH_SENS;
    const now = performance.now();
    const dt = Math.max(16, now - lastT);
    const impulse = (dy * 16 / dt) * 16; // un peu moins punchy
    if(mode==='dwell'){
      if(Math.abs(impulse) >= cfg.BREAK_FORCE){ exitDwell(true); vZ += impulse; }
    } else {
      vZ += impulse;
    }
    lastY = y; lastT = now;
    e.preventDefault();
  }, {passive:false});
  addEventListener('touchend', ()=>{ touching=false; }, {passive:true});

  /* boutons */
  let holdFw=false, holdBk=false;
  btnFw.addEventListener('pointerdown', ()=>{ if(mode==='dwell'){ exitDwell(true); } holdFw=true; vZ -= cfg.BTN_STEP; });
  btnBk.addEventListener('pointerdown', ()=>{ if(mode==='dwell'){ exitDwell(true); } holdBk=true; vZ += cfg.BTN_STEP; });
  addEventListener('pointerup', ()=>{ holdFw=false; holdBk=false; });

  /* clavier */
  addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(k==='arrowdown' || k==='pagedown'){ if(mode==='dwell'){ exitDwell(true); } vZ -= cfg.KEY_STEP*2; }
    if(k==='arrowup'   || k==='pageup'  ){ if(mode==='dwell'){ exitDwell(true); } vZ += cfg.KEY_STEP*2; }
  });

  function maybeEnterDwell(){
    if(mode==='dwell') return;
    const i = nearestLayerIndex(camZ);
    const z0 = +layers[i].dataset.z || 0;
    const d = Math.abs(z0 - camZ);
    if(d <= cfg.SNAP_WIN && Math.abs(vZ) < 60){ enterDwell(i); targetZ = z0; }
  }

  function render(){
    const now = performance.now();

    /* press & hold doux */
    if(mode!=='dwell'){
      if(holdFw) vZ -= 10;
      if(holdBk) vZ += 10;
    }

    /* dynamique adoucie */
    if(mode==='dwell'){
      // verrouillage sur la carte + amortissement
      if(focusedIndex>=0){
        const z0 = +layers[focusedIndex].dataset.z || 0;
        targetZ = z0;
      }
      vZ *= 0.78; // se calme vite pendant la pause
      if(now >= dwellTimer){ exitDwell(true); }
    } else {
      targetZ += vZ;
      vZ *= 0.82; // damping plus fort (moins “nerveux”)
    }

    targetZ = clamp(targetZ, cfg.zMin, cfg.zMax);
    camZ += (targetZ - camZ)*0.1;

    /* tilt easing */
    const ex=0.1; tiltX += (ttx - tiltX)*ex; tiltY += (tty - tiltY)*ex;
    scene.style.transform = `rotateX(${tiltX}deg) rotateY(${tiltY}deg)`;

    /* entrée en pause si conditions OK */
    maybeEnterDwell();

    /* rendu couches */
    for(let i=0;i<layers.length;i++){
      const L = layers[i];
      const z0 = +L.dataset.z||0;

      // STICK: si actif pour cette couche, ajoute un offset en Z qui suit la caméra
      let depthBase = z0 - camZ;
      if(stick.active && stick.index===i){
        const t = clamp((now - stick.startTime)/cfg.STICK_MS, 0, 1);
        const follow = (camZ - stick.startCamZ) * cfg.STICK_FACTOR * (1 - t); // décroît vers 0
        depthBase += follow;
        if(t>=1) stick.active=false; // fin du stick
      }

      const scale = clamp( 1 / (1 + (depthBase/1100)), cfg.scaleClampMin, cfg.scaleClampMax );

      // Opacité & blur — si stick, on “retarde” un peu la disparition (crédit px)
      let distanceForFade = Math.abs(depthBase);
      if(stick.active && stick.index===i){
        const t = clamp((now - stick.startTime)/cfg.STICK_MS, 0, 1);
        distanceForFade = Math.max(0, distanceForFade - (1 - t)*cfg.FADE_STICK_PX);
      }
      const o = clamp(1 - (distanceForFade/cfg.visibilityZ), 0, 1);
      const blur = (1 - Math.max(0, 1 - distanceForFade/900)) * cfg.blurMax;

      const yOffset = (depthBase/44);

      L.style.transform = `translate(-50%,-50%) translateZ(${depthBase}px) translateY(${yOffset}px) scale(${scale}) rotateX(${tiltX*0.35}deg) rotateY(${tiltY*0.35}deg)`;
      L.style.setProperty('--o', o.toFixed(3));
      L.style.setProperty('--blur', blur.toFixed(2)+'px');
      if(o < 0.05) L.setAttribute('aria-hidden','true'); else L.removeAttribute('aria-hidden');
    }

    updateHUD();
    requestAnimationFrame(render);
  }
  render();

  /* utils */
  addEventListener('resize', ()=>{}, {passive:true});
})();
</script>
</body>
</html>
